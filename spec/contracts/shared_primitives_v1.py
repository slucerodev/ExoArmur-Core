"""
Shared Primitives for ExoArmur Expansions (V1)
Canonical contracts used across Temporal, Analyst, and Forensics modules
"""

from datetime import datetime
from typing import List, Optional, Dict, Any, Literal
from pydantic import BaseModel, Field, ConfigDict, field_validator, field_serializer
import re


class EvidenceRefV1(BaseModel):
    """Canonical evidence reference for all module outputs"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True, frozen=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    evidence_id: str = Field(description="ULID evidence identifier")
    evidence_type: Literal["telemetry", "belief", "external", "derived"] = Field(description="Type of evidence")
    source_id: str = Field(description="Source identifier (event_id, belief_id, etc)")
    tenant_id: str = Field(description="Tenant identifier")
    timestamp_utc: datetime = Field(description="Evidence timestamp")
    hash_sha256: str = Field(description="SHA256 hash of evidence content")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional evidence metadata")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('evidence_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('evidence_id must be a valid ULID')
        return v


class BeliefDeltaV1(BaseModel):
    """Belief evolution delta emitted by Temporal module"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    delta_id: str = Field(description="ULID delta identifier")
    belief_id: str = Field(description="Target belief identifier")
    delta_type: Literal["create", "reinforce", "decay", "contradict"] = Field(description="Type of belief change")
    confidence_delta: float = Field(description="Change in confidence (-1.0 to 1.0)")
    new_confidence: float = Field(ge=0.0, le=1.0, description="Updated confidence score")
    evidence_refs: List[EvidenceRefV1] = Field(min_length=1, description="Supporting evidence references")
    reason: str = Field(description="Human-readable reason for belief change")
    temporal_context: Dict[str, Any] = Field(default_factory=dict, description="Temporal context metadata")
    timestamp_utc: datetime = Field(description="When delta was computed")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('delta_id', 'belief_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('ID must be a valid ULID')
        return v


class HypothesisV1(BaseModel):
    """Testable hypothesis generated by Analyst module"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    hypothesis_id: str = Field(description="ULID hypothesis identifier")
    title: str = Field(description="Hypothesis title")
    description: str = Field(description="Detailed hypothesis description")
    hypothesis_type: Literal["threat", "pattern", "causal", "correlation"] = Field(description="Type of hypothesis")
    confidence_score: float = Field(ge=0.0, le=1.0, description="Confidence in hypothesis validity")
    supporting_evidence: List[EvidenceRefV1] = Field(min_length=1, description="Evidence supporting hypothesis")
    contradicting_evidence: List[EvidenceRefV1] = Field(default_factory=list, description="Evidence contradicting hypothesis")
    testable_prediction: str = Field(description="Testable prediction from hypothesis")
    falsifiable_criteria: List[str] = Field(description="Criteria that would falsify hypothesis")
    analyst_assessment: Dict[str, Any] = Field(default_factory=dict, description="Analyst assessment metadata")
    timestamp_utc: datetime = Field(description="When hypothesis was generated")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('hypothesis_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('hypothesis_id must be a valid ULID')
        return v


class NarrativeV1(BaseModel):
    """Evidence-backed narrative generated by Analyst module"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    narrative_id: str = Field(description="ULID narrative identifier")
    title: str = Field(description="Narrative title")
    summary: str = Field(description="Executive summary of findings")
    detailed_analysis: str = Field(description="Detailed analysis with citations")
    narrative_type: Literal["threat_assessment", "incident_timeline", "pattern_analysis", "conclusion"] = Field(description="Type of narrative")
    confidence_level: Literal["low", "medium", "high"] = Field(description="Overall confidence level")
    key_findings: List[str] = Field(description="Key findings from analysis")
    supporting_hypotheses: List[HypothesisV1] = Field(min_length=1, description="Supporting hypotheses")
    evidence_citations: List[EvidenceRefV1] = Field(min_length=1, description="All evidence cited in narrative")
    analyst_confidence: float = Field(ge=0.0, le=1.0, description="Analyst confidence in narrative")
    recommendations: List[str] = Field(default_factory=list, description="Analyst recommendations")
    timestamp_utc: datetime = Field(description="When narrative was generated")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('narrative_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('narrative_id must be a valid ULID')
        return v


class FindingV1(BaseModel):
    """Specific finding with evidence backing"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    finding_id: str = Field(description="ULID finding identifier")
    title: str = Field(description="Finding title")
    description: str = Field(description="Detailed finding description")
    finding_type: Literal["vulnerability", "compromise", "anomaly", "pattern", "risk"] = Field(description="Type of finding")
    severity: Literal["low", "medium", "high", "critical"] = Field(description="Finding severity")
    confidence: float = Field(ge=0.0, le=1.0, description="Confidence in finding validity")
    evidence_refs: List[EvidenceRefV1] = Field(min_length=1, description="Supporting evidence references")
    affected_entities: List[str] = Field(description="Entities affected by this finding")
    impact_assessment: str = Field(description="Assessment of potential impact")
    mitigation_suggestions: List[str] = Field(default_factory=list, description="Suggested mitigations")
    timestamp_utc: datetime = Field(description="When finding was identified")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('finding_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('finding_id must be a valid ULID')
        return v


class TimelineEventV1(BaseModel):
    """Single timeline event with evidence backing"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    event_id: str = Field(description="ULID event identifier")
    timestamp_utc: datetime = Field(description="Event timestamp (may be estimated)")
    timestamp_precision: Literal["exact", "estimated", "bounded"] = Field(description="Precision of timestamp")
    timestamp_bounds: Optional[Dict[str, datetime]] = Field(default=None, description="Time bounds for estimated timestamps")
    event_type: str = Field(description="Type of timeline event")
    description: str = Field(description="Event description")
    entities_involved: List[str] = Field(description="Entities involved in event")
    evidence_refs: List[EvidenceRefV1] = Field(min_length=1, description="Supporting evidence references")
    confidence: float = Field(ge=0.0, le=1.0, description="Confidence in event placement")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional event metadata")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('event_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('event_id must be a valid ULID')
        return v


class TimelineV1(BaseModel):
    """Complete timeline with events and conflicts"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    timeline_id: str = Field(description="ULID timeline identifier")
    title: str = Field(description="Timeline title")
    description: str = Field(description="Timeline description")
    subject_entity: str = Field(description="Primary entity this timeline describes")
    time_bounds: Dict[str, datetime] = Field(description="Timeline start and end bounds")
    events: List[TimelineEventV1] = Field(min_length=1, description="Timeline events in chronological order")
    confidence_score: float = Field(ge=0.0, le=1.0, description="Overall timeline confidence")
    completeness_estimate: float = Field(ge=0.0, le=1.0, description="Estimated completeness of timeline")
    conflicts: List["ConflictV1"] = Field(default_factory=list, description="Conflicts in timeline")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional timeline metadata")
    generated_at_utc: datetime = Field(description="When timeline was generated")
    
    @field_serializer('time_bounds')
    def serialize_time_bounds(self, value: Dict[str, datetime]) -> Dict[str, str]:
        return {k: v.isoformat() for k, v in value.items()}
    
    @field_serializer('generated_at_utc')
    def serialize_generated_at_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('timeline_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('timeline_id must be a valid ULID')
        return v


class ConflictV1(BaseModel):
    """Explicit conflict representation for uncertainty"""
    
    model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)
    
    schema_version: str = Field(default="1.0.0", description="Schema version")
    conflict_id: str = Field(description="ULID conflict identifier")
    conflict_type: Literal["timestamp", "evidence", "interpretation", "completeness"] = Field(description="Type of conflict")
    description: str = Field(description="Conflict description")
    conflicting_items: List[Dict[str, Any]] = Field(min_length=2, description="Items that conflict")
    evidence_refs: List[EvidenceRefV1] = Field(min_length=1, description="Evidence supporting each side")
    resolution_status: Literal["unresolved", "resolved", "accepted_uncertainty"] = Field(default="unresolved")
    resolution_method: Optional[str] = Field(default=None, description="How conflict was resolved")
    uncertainty_bounds: Dict[str, Any] = Field(default_factory=dict, description="Bounds of uncertainty")
    impact_assessment: str = Field(description="Assessment of conflict impact")
    timestamp_utc: datetime = Field(description="When conflict was identified")
    
    @field_serializer('timestamp_utc')
    def serialize_timestamp_utc(self, value: datetime) -> str:
        return value.isoformat()
    
    @field_validator('conflict_id')
    @classmethod
    def validate_ulid(cls, v: str) -> str:
        if not re.match(r'^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$', v):
            raise ValueError('conflict_id must be a valid ULID')
        return v


# Forward reference resolution
TimelineV1.model_rebuild()

# Export all primitives for module use
__all__ = [
    "EvidenceRefV1",
    "BeliefDeltaV1", 
    "HypothesisV1",
    "NarrativeV1",
    "FindingV1",
    "TimelineEventV1",
    "TimelineV1",
    "ConflictV1",
]
